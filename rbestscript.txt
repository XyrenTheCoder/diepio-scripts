// ==UserScript==
// @name         [Diep.io] rbest = best
// @description  made with much fuck
// @version      1444
// @author       rbest (ft. _mikey____)
// @match        *://diep.io/*
// @match        *://diep-io.rivet.game/*
// @match        *://diepcustom.live/*
// @run-at       document-start
// @grant        GM_addStyle
// @require      https://www.gstatic.com/firebasejs/9.0.0/firebase-app-compat.js
// @require      https://www.gstatic.com/firebasejs/9.0.0/firebase-database-compat.js
// ==/UserScript==

(function() {
    'use strict';

    // ===== CORE VARIABLES =====
    const win = typeof unsafeWindow !== "undefined" ? unsafeWindow : window;
    let player;
    let minimap;
    let showedBuilds = false;
    let killCounter = 0;
    let yourScore = 0;
    let opponentScore = 0;
    let rawTime = 0;
    let time = '00:00:00';
    let timeInterval;
    let pressedO = false;
    let isActiveL = true;
    let isActiveK = true;
    let millionsCounter;
    let scoreboard;
    let baseZoneAlert;
    let locationSharingSystem;
    let hookManager;
    let mainGui;
    let buildGui;
    let settingsGui;
    let btnResetBinds;
    let btnAfk;
    let btnUpAndDown;
    let btnHideUI;
    let btnAutoRespawn;
    let btnBuildOL;
    let btnBuildSP;
    let btnBuildAN;
    let btnBuildRAM;
    let btnBuildFFAOL;
    let btnBuildPRED;
    let btnBuildFIGHTER;
    let lastMsTime = new Date();

    // ===== FIREBASE CONFIG =====
    const firebaseConfig = {
        apiKey: "AIzaSyC9J5gYDD2aoKta_TcFYbF_YoHGv19YYxc",
        authDomain: "diepio-locationsharing.firebaseapp.com",
        databaseURL: "https://diepio-locationsharing-default-rtdb.europe-west1.firebasedatabase.app",
        projectId: "diepio-locationsharing",
        storageBucket: "diepio-locationsharing.firebasestorage.app",
        messagingSenderId: "849873387342",
        appId: "1:849873387342:web:37dcc2dd227ad0be4d681f",
        measurementId: "G-VLJCP3EXR8"
    };

    // ===== UTILITY FUNCTIONS =====
    const createElement = (tag, attributes = {}, styles = {}, parent = null) => {
        const element = document.createElement(tag);

        Object.entries(attributes).forEach(([key, value]) => element[key] = value);

        if (typeof styles === 'string') {
            element.style.cssText = styles;
        } else {
            Object.entries(styles).forEach(([key, value]) => element.style[key] = value);
        }

        if (parent) parent.appendChild(element);

        return element;
    };

    const getScore = () => {
        const score = parseFloat(_rScore.slice(7).replace(/,/g, ''));
        const homeScreen = document.getElementById("home-screen");
        const gameOverScreen = document.getElementById("game-over-screen");
        const loadingScreen = document.getElementById("loading-screen");

        const isScreenVisible = element => element && window.getComputedStyle(element).display !== 'none';

        if (isScreenVisible(homeScreen) || isScreenVisible(gameOverScreen) || isScreenVisible(loadingScreen)) {
            return -1;
        }

        return score;
    };

    const createRateLimitedFunction = (fn, delay) => {
        let lastCall = 0;
        return function() {
            const now = Date.now();
            if (now - lastCall >= delay) {
                lastCall = now;
                fn();
            }
        };
    };

    const grantReward = createRateLimitedFunction(() => {
        extern.grantReward();
    }, 120000);

    // ===== STYLE DEFINITIONS =====
    const styles = {
        millionsCounter: `
        pointer-events: none;
        z-index: 9999;
        user-select: none;
        text-align: left;
        font-family: Ubuntu;
        color: #FFFFFF;
        font-style: normal;
        font-size: 2.55vh;
        opacity: 100%;
        text-shadow: black 0.18vh 0vh, black -0.18vh 0vh, black 0vh -0.18vh, black 0vh 0.18vh, black 0.18vh 0.18vh, black -0.18vh 0.18vh, black 0.18vh -0.18vh, black -0.18vh -0.18vh, black 0.09vh 0.18vh, black -0.09vh 0.18vh, black 0.09vh -0.18vh, black -0.09vh -0.18vh, black 0.18vh 0.09vh, black -0.18vh 0.09vh, black 0.18vh -0.09vh, black -0.18vh -0.09vh;
    `,
        millionsTitle: `
        font-size: 3.9vh;
        text-shadow: black 0.2vh 0vh, black -0.2vh 0vh, black 0vh -0.2vh, black 0vh 0.2vh, black 0.2vh 0.2vh, black -0.2vh 0.2vh, black 0.2vh -0.2vh, black -0.2vh -0.2vh, black 0.1vh 0.2vh, black -0.1vh 0.2vh, black 0.1vh -0.2vh, black -0.1vh -0.2vh, black 0.2vh 0.1vh, black -0.2vh 0.1vh, black 0.2vh -0.1vh, black -0.2vh -0.1vh;
    `,
        scoreboard: `
        opacity: 0;
        transition: opacity 0.5s ease, visibility 0.5s;
        overflow: hidden;
        position: fixed;
        top: 100px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        justify-content: space-between;
        align-items: center;
        opacity: 65%;
        text-shadow: 0.18vh 0vh black, -0.18vh 0vh black, 0vh -0.18vh black, 0vh 0.18vh black, 0.18vh 0.18vh black, -0.18vh 0.18vh black, 0.18vh -0.18vh black, -0.18vh -0.18vh black, 0.09vh 0.18vh black, -0.09vh 0.18vh black, 0.09vh -0.18vh black, -0.09vh -0.18vh black, 0.18vh 0.09vh black, -0.18vh 0.09vh black, 0.18vh -0.09vh black, -0.18vh -0.09vh black;
    `,
        baseZoneAlert: `
        pointer-events: none;
        user-select: none;
        text-align: center;
        font-family: Ubuntu;
        font-style: normal;
        font-size: 3.85vh;
        opacity: 65%;
        text-shadow: black 0.18vh 0vh, black -0.18vh 0vh, black 0vh -0.18vh, black 0vh 0.18vh, black 0.18vh 0.18vh, black -0.18vh 0.18vh, black 0.18vh -0.18vh, black -0.18vh -0.18vh, black 0.09vh 0.18vh, black -0.09vh 0.18vh, black 0.09vh -0.18vh, black -0.09vh -0.18vh, black 0.18vh 0.09vh, black -0.18vh 0.09vh, black 0.18vh -0.09vh, black -0.18vh -0.09vh;
    `
    };

    // ===== CANVAS HOOK SYSTEM =====
    let _rScore = "0";

    class CanvasHookManager {
        constructor() {
            this.callbacks = new Set();
            this.pendingCalls = new Map();
            this.methodsToProxy = [
                'beginPath', 'moveTo', 'lineTo', 'fill', 'fillRect',
                'fillText', 'strokeText', 'strokeRect'
            ];
            this.start();
        }

        addCallback(callback) {
            if (typeof callback !== 'function') return false;
            this.callbacks.add(callback);
            return () => this.removeCallback(callback);
        }

        removeCallback(callback) {
            if (this.callbacks.has(callback)) {
                this.callbacks.delete(callback);
                return true;
            }
            return false;
        }

        addPendingCall(ctx, method, args) {
            if (!this.pendingCalls.has(ctx)) {
                this.pendingCalls.set(ctx, []);
            }
            this.pendingCalls.get(ctx).push({ method, args });
        }

        executePendingCalls(ctx) {
            if (this.pendingCalls.has(ctx)) {
                const calls = this.pendingCalls.get(ctx);
                this.pendingCalls.delete(ctx);

                for (const call of calls) {
                    const originalMethod = ctx[call.method];
                    if (typeof originalMethod === 'function') {
                        originalMethod.apply(ctx, call.args);
                    }
                }
            }
        }

        start() {
            const self = this;
            const originalCreateElement = document.createElement;

            document.createElement = new Proxy(originalCreateElement, {
                apply(target, thisArg, args) {
                    const el = target.apply(thisArg, args);
                    if (el instanceof HTMLCanvasElement) {
                        const ctx = el.getContext('2d');
                        if (ctx) {
                            for (const method of self.methodsToProxy) {
                                const originalMethod = ctx[method];
                                if (typeof originalMethod !== 'function') continue;

                                const methodProxy = new Proxy(originalMethod, {
                                    apply(target, thisArg, args) {
                                        let shouldCallOriginal = true;
                                        let hasPendingCalls = false;

                                        const argsCopy = [...args];

                                        for (const callback of self.callbacks) {
                                            try {
                                                const result = callback(thisArg, argsCopy, method, (callMethod, callArgs) => {
                                                    self.addPendingCall(thisArg, callMethod, callArgs);
                                                    hasPendingCalls = true;
                                                });

                                                if (result === false) {
                                                    shouldCallOriginal = false;
                                                }
                                            } catch (e) {
                                                console.error(`Error in callback for ${method}:`, e);
                                            }
                                        }

                                        let result;
                                        if (shouldCallOriginal) {
                                            result = target.apply(thisArg, argsCopy);
                                        }

                                        if (hasPendingCalls) {
                                            self.executePendingCalls(thisArg);
                                        }

                                        return result;
                                    }
                                });

                                try {
                                    Object.defineProperty(ctx, method, {
                                        configurable: true,
                                        enumerable: true,
                                        writable: true,
                                        value: methodProxy
                                    });
                                } catch (e) {
                                    ctx[method] = methodProxy;
                                }
                            }
                        }
                    }
                    return el;
                }
            });
        }
    }

    function hookAllCanvasMethods(callback) {
        return hookManager.addCallback(callback);
    }

    // ===== MINIMAP CLASS =====
    class Minimap {
        constructor() {
            this._minimapWidth = 0;
            this._minimapHeight = 0;
            this._x00 = 0;
            this._y00 = 0;
            this._pointX = 0;
            this._pointY = 0;
            this._x = 0;
            this._y = 0;

            this._setupHooks();
        }

        _setupHooks() {
            const minimapCallback = (thisArg, args, prop) => {
                if (prop === 'strokeRect') {
                    const transform = thisArg.getTransform();
                    this._minimapWidth = transform.a;
                    this._minimapHeight = transform.d;
                    this._x00 = transform.e;
                    this._y00 = transform.f;
                }
                return true;
            };

            const arrowCallback = (thisArg, args, prop) => {
                if (prop === 'beginPath') {
                    this._index = 1;
                } else if (prop === 'moveTo' && this._index === 1) {
                    this._pointA = args;
                    this._index = 2;
                } else if (prop === 'lineTo' && this._index === 2) {
                    this._pointB = args;
                    this._index = 3;
                } else if (prop === 'lineTo' && this._index === 3) {
                    this._pointC = args;
                    this._index = 4;
                } else if (prop === 'fill' && this._index === 4 && thisArg.globalAlpha > 0.9 && thisArg.fillStyle === '#000000') {
                    this._calculatePosition();
                    this._index = 0;
                }
                return true;
            };
            hookManager.addCallback(minimapCallback);
            hookManager.addCallback(arrowCallback);
        }

        _calculatePosition() {
            if (!this._pointA || !this._pointB || !this._pointC) return;

            this._pointX = (this._pointA[0] + this._pointB[0] + this._pointC[0]) / 3;
            this._pointY = (this._pointA[1] + this._pointB[1] + this._pointC[1]) / 3;

            this._x = (this._pointX - this._x00) / this._minimapWidth;
            this._y = (this._pointY - this._y00) / this._minimapHeight;
        }
    }

    // ===== PLAYER CLASS =====
    class Player {
        constructor() {
            this._minimap = new Minimap();
            this._dead = true;
            this._tank = '';
            this._score = -1;
            this._stats = {
                healthRegen: 0,
                maxHealth: 0,
                bodyDamage: 0,
                bulletSpeed: 0,
                bulletPenetration: 0,
                bulletDamage: 0,
                reload: 0,
                movementSpeed: 0,
            };

            this._setupDeadListener();
            this._setupCanvasHook();
            this._setupStatsUpdater();
        }

        _setupStatsUpdater() {
            setInterval(() => {
                if (!this._dead) {
                    this._updateStats();
                }
            }, 100);
        }

        _updateStats() {
            this._stats = this._getStats();
        }

        _getStats() {
            const buildStatLevels = [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 30, 33, 36, 39, 42, 45];

            const rawStats = extern.get_convar("game_stats_build");
            let stats = {
                healthRegen: 0,
                maxHealth: 0,
                bodyDamage: 0,
                bulletSpeed: 0,
                bulletPenetration: 0,
                bulletDamage: 0,
                reload: 0,
                movementSpeed: 0,
            };
            const statNumbers = {
                1: "healthRegen",
                2: "maxHealth",
                3: "bodyDamage",
                4: "bulletSpeed",
                5: "bulletPenetration",
                6: "bulletDamage",
                7: "reload",
                8: "movementSpeed"
            };
            for (let i = 0; i < rawStats.length; ++i) {
                ++stats[statNumbers[rawStats[i]]];
            }
            return stats;
        }

        get stats() {
            return { ...this._stats };
        }

        _setupDeadListener() {
            setInterval(() => {
                if (!win.input) return;
                const isDead = !(getScore() >= 0);
                if (this._dead === isDead) return;

                this._dead = isDead;
                if (this._dead) this.ondead();
                else this.onspawn();
            }, 20);
        }

        _setupCanvasHook() {
            const canvasCallback = (thisArg, args, prop) => {
                if (prop === 'fillText') {
                    const [text, x, y, ...rest] = args;

                    const patternTank = /Lvl (\d{2}|[1-9])(.*?)$/;
                    const match = text.match(patternTank);
                    if (match) {
                        this._tank = match[2].trim();
                    }

                    if (text.startsWith('Score: ')) {
                        _rScore = text;
                        const scoreFromText = parseFloat(text.slice(7).replace(/,/g, ''));
                        const gameOverScoreElement = document.getElementById("game-over-stats-player-score");
                        const gameOverScore = gameOverScoreElement
                        ? parseFloat(gameOverScoreElement.textContent.trim().replace(/,/g, ''))
                        : 0;
                        this._score = Math.max(scoreFromText, gameOverScore);
                    }
                }
            };

            hookAllCanvasMethods(canvasCallback);
        }

        get x() {
            return this._minimap._x;
        }

        get y() {
            return this._minimap._y;
        }

        get dead() {
            return this._dead;
        }

        get tank() {
            return this._tank;
        }

        get score() {
            return this._score;
        }

        get gamemode() {
            const gamemode_sel_btn = document.querySelector("#gamemode-selector > div > div.selected");
            return gamemode_sel_btn ? gamemode_sel_btn.getAttribute("value") : '';
        }

        get region() {
            const gamemode_sel_btn = document.querySelector("#region-selector > div > div.selected");
            return gamemode_sel_btn ? gamemode_sel_btn.getAttribute("value") : '';
        }

        goto(x, y) {
            const dX = x - this.x;
            const dY = y - this.y;

            if (dX > 0) {
                extern.onKeyDown(4);
                extern.onKeyUp(1);
            } else {
                extern.onKeyDown(1);
                extern.onKeyUp(4);
            }

            if (dY > 0) {
                extern.onKeyDown(19);
                extern.onKeyUp(23);
            } else {
                extern.onKeyDown(23);
                extern.onKeyUp(19);
            }
        }

        ondead() {
            showedBuilds = false;
            updateMillionsCounter(this.score);

            if (btnAutoRespawn && btnAutoRespawn.active && this.score <= 300000) {
                resetTimer();
                respawnPlayer();
            }
        }

        onspawn() {
            killCounter = 0;
            this._stats = {
                healthRegen: 0,
                maxHealth: 0,
                bodyDamage: 0,
                bulletSpeed: 0,
                bulletPenetration: 0,
                bulletDamage: 0,
                reload: 0,
                movementSpeed: 0,
            };
        }
    }

    // ===== GUI CLASSES =====
    class BaseGui {
        constructor(position) {
            this._buttons = [];
            this._keyCodeButtons = [];
            this._defaultKeyCodes = {};
            this._colors = ['#2B2D2F'];
            this._gui = null;
            this._guiBody = null;
            this._position = position;
            this._nonce = `a${(Math.random() * 1e5) | 0}`;
            this._keyDownHandler = null;

            this._createGui(position);
            this._setupKeyboardShortcuts();
        }

        _createGui(position) {
            GM_addStyle(
                `.${this._nonce} {
                position: absolute;
                top: 0;
                ${this._position === 'right' ? 'right: 0;' : 'left: 0;'}
                text-align: ${this._position === 'right' ? 'right' : 'left'};
            }
            .${this._nonce} .button-wrapper {
                display: flex;
                align-items: center;
                justify-content: flex-start;
                width: 100%;
                z-index: 9998;
            }
            .${this._nonce} button {
                font-family: Ubuntu;
                color: #fff;
                text-shadow: -.1em -.1em 0 #000, 0 -.1em 0 #000, .1em -.1em 0 #000, .1em 0 0 #000, .1em .1em 0 #000, 0 .1em 0 #000, -.1em .1em 0 #000, -.1em 0 0 #000;
                opacity: 0.8;
                padding: .3em .5em;
                width: 100%;
                transition: all .15s;
                white-space: nowrap;
                z-index: 9998;
            }
            .${this._nonce} .keycode-button {
                width: 30px;
                background-color: #2B2D2F;
                z-index: 9999;
            }
            .${this._nonce} button:active:not([disabled]) {
                filter: brightness(1.5);
            }
            .${this._nonce} button:hover:not([disabled]):not(:active) {
                filter: brightness(1.5);
            }`
            );

            this._gui = document.createElement('div');
            this._gui.className = this._nonce;
            this._guiBody = document.createElement('div');
            this._guiBody.style.display = 'block';

            document.body.appendChild(this._gui);
            this._gui.appendChild(this._guiBody);
        }

        addButton(text, onclick, keyCode = null) {
            this._defaultKeyCodes[text] = keyCode;

            const buttonWrapper = document.createElement('div');
            buttonWrapper.className = 'button-wrapper';

            const keyCodeButton = document.createElement('button');
            keyCodeButton.className = 'keycode-button';
            keyCodeButton.onclick = () => this._setKeyCode(mainButton, keyCodeButton);

            const mainButton = document.createElement('button');
            mainButton.innerHTML = text;
            mainButton.onclick = onclick;

            const storageKey = this._position === 'right' ? 'buttonKeyCodes' : 'buildButtonKeyCodes';
            const savedCustomKeyBindings = JSON.parse(localStorage.getItem(storageKey));
            if (savedCustomKeyBindings && savedCustomKeyBindings[text]) {
                mainButton.keyCode = savedCustomKeyBindings[text];
            } else {
                mainButton.keyCode = keyCode;
            }

            keyCodeButton.innerHTML = mainButton.keyCode ? codeToKey[mainButton.keyCode] : '-';

            if (text === "Prediction Movement" && localStorage.getItem('predictionMovement') === "true") {
                mainButton.style.backgroundColor = "#008000";
                mainButton.active = true;
            } else {
                mainButton.style.backgroundColor = this._colors[this._buttons.length % this._colors.length];
            }

            buttonWrapper.appendChild(keyCodeButton);
            buttonWrapper.appendChild(mainButton);

            this._guiBody.appendChild(buttonWrapper);
            this._buttons.push(mainButton);
            this._keyCodeButtons.push(keyCodeButton);
            return mainButton;
        }

        resetKeyCodes() {
            this._buttons.forEach((button) => {
                let text = button.innerHTML;
                if (text.startsWith('0')) text = '00:00:00';
                button.keyCode = this._defaultKeyCodes[text];
                const keyCodeBtn = button.parentNode.querySelector('.keycode-button');
                if (keyCodeBtn) {
                    keyCodeBtn.innerHTML = button.keyCode ? codeToKey[button.keyCode] : '-';
                }
            });

            const storageKey = this._position === 'right' ? 'buttonKeyCodes' : 'buildButtonKeyCodes';
            localStorage.setItem(storageKey, JSON.stringify(this._defaultKeyCodes));
        }

        removeButton(button) {
            button.active = false;
            button.parentNode.remove();
            const buttonIndex = this._buttons.indexOf(button);
            if (buttonIndex !== -1) {
                this._buttons.splice(buttonIndex, 1);
            }
            const keyCodeButton = button.parentNode.querySelector('.keycode-button');
            const keyCodeButtonIndex = this._keyCodeButtons.indexOf(keyCodeButton);
            if (keyCodeButtonIndex !== -1) {
                this._keyCodeButtons.splice(keyCodeButtonIndex, 1);
            }
        }

        destroy() {
            document.removeEventListener('keydown', this._keyDownHandler);
            this._buttons.forEach((button) => {
                this.removeButton(button);
            });
            this._guiBody.remove();
            this._gui.remove();
        }

        _setKeyCode(button, keyCodeButton) {
            keyCodeButton.innerHTML = '...';
            keyCodeButton.style.backgroundColor = "#008000";

            const keyPressHandler = (event) => {
                if (event.isTrusted) {
                    if (event.key === "-") {
                        button.keyCode = null;
                        keyCodeButton.innerHTML = '-';
                    } else {
                        button.keyCode = event.code;
                        keyCodeButton.innerHTML = codeToKey[event.code] || event.code;
                    }

                    document.removeEventListener('keydown', keyPressHandler);

                    const storageKey = this._position === 'right' ? 'buttonKeyCodes' : 'buildButtonKeyCodes';
                    let buttonKeyCodes = JSON.parse(localStorage.getItem(storageKey)) || {};
                    let text = button.innerHTML;
                    if (text.startsWith('0')) text = '00:00:00';
                    buttonKeyCodes[text] = button.keyCode;
                    localStorage.setItem(storageKey, JSON.stringify(buttonKeyCodes));

                    keyCodeButton.style.backgroundColor = "#2B2D2F";
                }
            };

            document.addEventListener('keydown', keyPressHandler);
        }

        _setupKeyboardShortcuts() {
            this._keyDownHandler = (event) => {
                if (document.getElementById('textInputContainer').style.display === 'block') return;

                this._buttons.forEach((button) => {
                    if (event.isTrusted && button.keyCode === event.code && ((!player.dead) || (event.altKey && player.dead))) {
                        button.onclick();
                        if (this._guiBody.style.display === 'none') {
                            if (button.active) {
                                input.inGameNotification(button.innerHTML, 3273729, 3000);
                            } else {
                                input.inGameNotification(button.innerHTML, 0, 3000);
                            }
                        }
                    }
                });
            };
            document.addEventListener('keydown', this._keyDownHandler);
        }
    }
    class SettingsGui {
        constructor() {
            this._buttons = [];
            this._colors = ['#2B2D2F'];
            this._gui = null;
            this._guiBody = null;

            this._createGui();
        }

        _createGui() {
            const guiContainer = createElement('div', {}, {
                position: 'absolute',
                top: '50%',
                left: '50%',
                transform: 'translate(-50%, -50%)',
                zIndex: '9999'
            }, document.body);

            this._gui = guiContainer;
            this._guiBody = createElement('div', {}, { display: 'none' }, this._gui);
        }

        addButton(text, onclick, keyCode = null) {
            const button = createElement('button', {
                innerHTML: text,
                keyCode: keyCode,
                onclick: onclick
            }, {
                display: 'block',
                fontFamily: 'Ubuntu',
                color: '#fff',
                textShadow: '-.1em -.1em 0 #000, 0 -.1em 0 #000, .1em -.1em 0 #000, .1em 0 0 #000, .1em .1em 0 #000, 0 .1em 0 #000, -.1em .1em 0 #000, -.1em 0 0 #000',
                opacity: '0.8',
                border: '0',
                padding: '.3em .5em',
                width: '100%',
                transition: 'all .15s',
                backgroundColor: this._colors[this._buttons.length % this._colors.length]
            }, this._guiBody);

            this._buttons.push(button);
            return button;
        }

        reset() {
            const head = this._buttons[0];
            this._buttons.forEach((x, i) => {
                if (i === 0) return;
                x.remove();
            });
            this._buttons = [head];
        }
    }

    // ===== FIREBASE LOCATION SHARING =====
    class LocationSharing {
        constructor() {
            this.userId = this._generateUserId();
            this.otherUsers = {};
            this.inactiveTimeout = 10000;
            this.active = false;

            this._initFirebase();
        }

        _generateUserId() {
            return 'user_' + Math.random().toString(36).substring(2, 15);
        }

        _initFirebase() {
            localStorage.removeItem('firebase:previous_websocket_failure');
            this.app = firebase.initializeApp(firebaseConfig);
            this.database = firebase.database();
        }

        activate() {
            if (this.active) return;

            this.active = true;
            this._getOtherUsersCoordinates();
            this.sendCoordinatesInterval = setInterval(() => this._sendCoordinates(), 100);
            this.removeInactiveUsersInterval = setInterval(() => this._removeInactiveUsers(), 5000);
            this._displayOtherUsersOnMinimap();
        }

        deactivate() {
            if (!this.active) return;

            this.active = false;
            clearInterval(this.sendCoordinatesInterval);
            clearInterval(this.removeInactiveUsersInterval);
            this.otherUsers = {};
        }

        _getPlayerName() {
            try {
                const name = localStorage.getItem('d:last_spawn_name');
                return name ? name.slice(1, -1) : "Unknown";
            } catch (e) {
                return "Unknown";
            }
        }

        _sendCoordinates() {
            const coordinates = { x: player.x, y: player.y };
            const playerName = this._getPlayerName();
            const region = player.region;
            const gamemode = player.gamemode;

            if (coordinates.x && coordinates.y) {
                this.database.ref('users/' + this.userId).set({
                    x: coordinates.x,
                    y: coordinates.y,
                    name: playerName,
                    region: region,
                    gamemode: gamemode,
                    lastUpdate: firebase.database.ServerValue.TIMESTAMP
                });
            }
        }

        _getOtherUsersCoordinates() {
            this.database.ref('users').on('value', (snapshot) => {
                const users = snapshot.val();
                if (users) {
                    this.otherUsers = {};
                    const myRegion = player.region;
                    const myGamemode = player.gamemode;

                    for (const id in users) {
                        if (users.hasOwnProperty(id) && id !== this.userId) {
                            const user = users[id];
                            if (user.region === myRegion && user.gamemode === myGamemode) {
                                this.otherUsers[id] = user;
                            }
                        }
                    }
                }
            });
        }

        _removeInactiveUsers() {
            this.database.ref('users').once('value', (snapshot) => {
                const users = snapshot.val();
                if (users) {
                    const now = Date.now();
                    for (const id in users) {
                        if (users.hasOwnProperty(id)) {
                            const user = users[id];
                            if (user.lastUpdate && (now - user.lastUpdate > this.inactiveTimeout)) {
                                this.database.ref('users/' + id).remove();
                            }
                        }
                    }
                }
            });
        }

        _displayOtherUsersOnMinimap() {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');

            const displayUsers = () => {
                if (!this.active) return;

                for (const userId in this.otherUsers) {
                    if (this.otherUsers.hasOwnProperty(userId)) {
                        const user = this.otherUsers[userId];
                        const coords = this._transformCoordinates(user.x, user.y);

                        ctx.fillStyle = '#00FF00';
                        ctx.beginPath();
                        ctx.arc(coords.x, coords.y, 5, 0, 2 * Math.PI);
                        ctx.globalAlpha = 1;
                        ctx.fill();

                        ctx.fillStyle = '#000000';
                        ctx.font = `${12 * window.devicePixelRatio}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.fillText(user.name, coords.x, coords.y - 10);
                    }
                }

                requestAnimationFrame(displayUsers);
            };

            displayUsers();
        }

        _transformCoordinates(x, y) {
            const canvas = document.getElementById('canvas');
            const minimapSize = minimap._minimapHeight;
            const minimapX = canvas.width - minimapSize;
            const minimapY = canvas.height - minimapSize;

            const transformedX = minimapX + x * minimapSize - 18.48;
            const transformedY = minimapY + y * minimapSize - 18.48;

            return { x: transformedX, y: transformedY };
        }
    }

    // ===== MILLIONS COUNTER =====
    class MillionsCounter {
        constructor() {
            this.totalMillions = {
                m1: parseInt(localStorage.getItem('Total_1ms') || '0'),
                m2: parseInt(localStorage.getItem('Total_2ms') || '0'),
                m3: parseInt(localStorage.getItem('Total_3ms') || '0'),
                m4: parseInt(localStorage.getItem('Total_4ms') || '0')
            };

            this.yearMillions = {
                m1: parseInt(localStorage.getItem('This_year_1ms') || '0'),
                m2: parseInt(localStorage.getItem('This_year_2ms') || '0'),
                m3: parseInt(localStorage.getItem('This_year_3ms') || '0'),
                m4: parseInt(localStorage.getItem('This_year_4ms') || '0')
            };

            this.year = new Date().getFullYear();
            this._checkYearChange();
            this._createCounters();
        }

        _checkYearChange() {
            if (localStorage.getItem('LastSessionYear') === null) {
                localStorage.setItem('LastSessionYear', this.year);
            }

            if (parseInt(localStorage.getItem('LastSessionYear')) !== this.year) {
                localStorage.setItem('LastSessionYear', this.year);
                localStorage.setItem('This_year_1ms', '0');
                localStorage.setItem('This_year_2ms', '0');
                localStorage.setItem('This_year_3ms', '0');
                localStorage.setItem('This_year_4ms', '0');

                this.yearMillions = { m1: 0, m2: 0, m3: 0, m4: 0 };
            }
        }

        _createCounters() {
            // Total millions counter
            this.totalElement = createElement('div', {}, {
                bottom: '43%',
                left: '1.3%',
                display: 'none',
                position: 'fixed',
                zIndex: '9999'
            }, document.body);

            // This year millions counter
            this.yearElement = createElement('div', {}, {
                bottom: '43%',
                right: '1.3%',
                display: 'none',
                position: 'fixed',
                zIndex: '9999'
            }, document.body);

            this.update();
        }

        update(score = -1, increment = false) {
            // Only update counters if player died with a high score
            if (score >= 1000000 && increment) {
                if (score >= 4000000) {
                    this._incrementCounter('m4');
                    this._incrementCounter('m3');
                    this._incrementCounter('m2');
                    this._incrementCounter('m1');
                } else if (score >= 3000000) {
                    this._incrementCounter('m3');
                    this._incrementCounter('m2');
                    this._incrementCounter('m1');
                } else if (score >= 2000000) {
                    this._incrementCounter('m2');
                    this._incrementCounter('m1');
                } else {
                    this._incrementCounter('m1');
                }
            }

            // Update total counter display
            this.totalElement.innerHTML = `
            <div class="parent" style="${styles.millionsCounter}">
                <div class="child" style="${styles.millionsTitle}">Total</div>
                <div class="child">1millions: ${this.totalMillions.m1}${score >= 1000000 && increment ? '<span style="color: #7CFC00">+1</span>' : ''}</div>
                <div class="child">2millions: ${this.totalMillions.m2}${score >= 2000000 && increment ? '<span style="color: #7CFC00">+1</span>' : ''}</div>
                <div class="child">3millions: ${this.totalMillions.m3}${score >= 3000000 && increment ? '<span style="color: #7CFC00">+1</span>' : ''}</div>
                <div class="child">4millions: ${this.totalMillions.m4}${score >= 4000000 && increment ? '<span style="color: #7CFC00">+1</span>' : ''}</div>
            </div>
        `;

            // Update year counter display
            this.yearElement.innerHTML = `
            <div class="parent" style="${styles.millionsCounter}">
                <div class="child" style="${styles.millionsTitle}">${this.year}</div>
                <div class="child">1millions: ${this.yearMillions.m1}${score >= 1000000 && increment ? '<span style="color: #7CFC00">+1</span>' : ''}</div>
                <div class="child">2millions: ${this.yearMillions.m2}${score >= 2000000 && increment ? '<span style="color: #7CFC00">+1</span>' : ''}</div>
                <div class="child">3millions: ${this.yearMillions.m3}${score >= 3000000 && increment ? '<span style="color: #7CFC00">+1</span>' : ''}</div>
                <div class="child">4millions: ${this.yearMillions.m4}${score >= 4000000 && increment ? '<span style="color: #7CFC00">+1</span>' : ''}</div>
            </div>
        `;
        }

        _incrementCounter(level) {
            this.totalMillions[level]++;
            this.yearMillions[level]++;

            localStorage.setItem(`Total_${level}`, this.totalMillions[level]);
            localStorage.setItem(`This_year_${level}`, this.yearMillions[level]);
        }

        show() {
            this.totalElement.style.display = 'block';
            this.yearElement.style.display = 'block';
        }

        hide() {
            this.totalElement.style.display = 'none';
            this.yearElement.style.display = 'none';
        }

        createEditableCounters() {
            this.totalElement.innerHTML = `
            <div class="parent" style="${styles.millionsCounter}; pointer-events: auto;">
                <div class="child" style="${styles.millionsTitle}">Total</div>
                <div class="child">1millions: <input type="number" id="Total_m1_input" value="${this.totalMillions.m1}" style="width: 40px"></div>
                <div class="child">2millions: <input type="number" id="Total_m2_input" value="${this.totalMillions.m2}" style="width: 40px"></div>
                <div class="child">3millions: <input type="number" id="Total_m3_input" value="${this.totalMillions.m3}" style="width: 40px"></div>
                <div class="child">4millions: <input type="number" id="Total_m4_input" value="${this.totalMillions.m4}" style="width: 40px"></div>
            </div>
        `;

            this.yearElement.innerHTML = `
            <div class="parent" style="${styles.millionsCounter}; pointer-events: auto;">
                <div class="child" style="${styles.millionsTitle}">${this.year}</div>
                <div class="child">1millions: <input type="number" id="This_year_m1_input" value="${this.yearMillions.m1}" style="width: 40px"></div>
                <div class="child">2millions: <input type="number" id="This_year_m2_input" value="${this.yearMillions.m2}" style="width: 40px"></div>
                <div class="child">3millions: <input type="number" id="This_year_m3_input" value="${this.yearMillions.m3}" style="width: 40px"></div>
                <div class="child">4millions: <input type="number" id="This_year_m4_input" value="${this.yearMillions.m4}" style="width: 40px"></div>
            </div>
        `;

            // Add event listeners to inputs
            document.querySelectorAll('input[type="number"]').forEach(input => {
                input.addEventListener('input', () => {
                    const newValue = parseInt(input.value);
                    const id = input.id;

                    if (id.startsWith('Total_')) {
                        const level = id.split('_')[1];
                        this.totalMillions[level] = newValue;
                        localStorage.setItem(`Total_${level.replace('m', '')}ms`, newValue);
                    } else if (id.startsWith('This_year_')) {
                        const level = id.split('_')[2];
                        this.yearMillions[level] = newValue;
                        localStorage.setItem(`This_year_${level.replace('m', '')}ms`, newValue);
                    }
                });
            });
        }
    }

    // ===== SCOREBOARD =====
    class Scoreboard {
        constructor() {
            this.yourScore = 0;
            this.opponentScore = 0;
            this._createScoreboard();
        }

        _createScoreboard() {
            this.element = createElement('div', {}, {
                visibility: 'hidden'
            }, document.body);

            this.element.innerHTML = `
            <div class="scoreboard">
                <div class="player">
                    <span>You</span>
                    <strong class="yourScore">${this.yourScore}</strong>
                </div>
                <div class="player">
                    <span>Opponent</span>
                    <strong class="opponentScore">${this.opponentScore}</strong>
                </div>
            </div>
        `;

            // Add styles
            const styleElement = createElement('style', {
                textContent: `
                .scoreboard {
                    opacity: 0;
                    transition: opacity 0.5s ease, visibility 0.5s;
                    overflow: hidden;
                    position: fixed;
                    top: 100px;
                    left: 50%;
                    transform: translateX(-50%);
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    opacity: 65%;
                    text-shadow: 0.18vh 0vh black, -0.18vh 0vh black, 0vh -0.18vh black, 0vh 0.18vh black, 0.18vh 0.18vh black, -0.18vh 0.18vh black, 0.18vh -0.18vh black, -0.18vh -0.18vh black, 0.09vh 0.18vh black, -0.09vh 0.18vh black, 0.09vh -0.18vh black, -0.09vh -0.18vh black, 0.18vh 0.09vh black, -0.18vh 0.09vh black, 0.18vh -0.09vh black, -0.18vh -0.09vh black;
                }
                .player {
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    font-family: Arial, sans-serif;
                    color: #333;
                }
                .player:first-child {
                    color: #00e16e;
                    margin-right: 200px;
                }
                .player:last-child {
                    color: #f14e54;
                }
                .player span {
                    font-size: 28px;
                }
                .player strong {
                    font-size: 48px;
                }
            `
            }, {}, document.head);

            // Load GSAP for animations
            const scriptElement = createElement('script', {
                src: "https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js",
                onload: this._setupAnimations.bind(this)
            }, {}, document.head);
        }

        _setupAnimations() {
            window.updateScoreAnimated = (newYourScore, newOpponentScore) => {
                const yourScoreElem = document.querySelector('.yourScore');
                const opponentScoreElem = document.querySelector('.opponentScore');
                const tl = gsap.timeline();

                tl.to('.scoreboard', { duration: 0.5, opacity: '65%', visibility: 'visible' });

                if (newYourScore !== this.yourScore) {
                    tl.to(yourScoreElem, { duration: 0.3, scale: 0, opacity: 1, ease: "power2.inOut" })
                        .call(() => {
                        yourScoreElem.innerText = newYourScore;
                        this.yourScore = newYourScore;
                    })
                        .to(yourScoreElem, { duration: 0.3, scale: 1, opacity: 1, ease: "power2.inOut" }, '+=0.2');
                }

                if (newOpponentScore !== this.opponentScore) {
                    tl.to(opponentScoreElem, { duration: 0.3, scale: 0, opacity: 1, ease: "power2.inOut" })
                        .call(() => {
                        opponentScoreElem.innerText = newOpponentScore;
                        this.opponentScore = newOpponentScore;
                    })
                        .to(opponentScoreElem, { duration: 0.3, scale: 1, opacity: 1, ease: "power2.inOut" }, '+=0.2');
                }

                tl.to('.scoreboard', { duration: 0.5, opacity: 0 }, '+=1')
                    .to('.scoreboard', { duration: 0.5, opacity: 0, visibility: 'hidden' }, '+=0.2');

                this.updateName();
            };
        }

        updateName() {
            const scoreRegex = /^\d{1,2}-\d{1,2}/;
            // Update player name with score if needed
        }

        createEditableScoreboard() {
            this.element.style.visibility = 'visible';
            this.element.innerHTML = `
            <div class="scoreboard">
                <div class="player">
                    <span>You</span>
                    <div>
                        <button class="decrease">-</button>
                        <strong class="yourScore">${this.yourScore}</strong>
                        <button class="increase">+</button>
                    </div>
                </div>
                <div class="player">
                    <span>Opponent</span>
                    <div>
                        <button class="decrease">-</button>
                        <strong class="opponentScore">${this.opponentScore}</strong>
                        <button class="increase">+</button>
                    </div>
                </div>
            </div>
        `;

            // Add styles for editable scoreboard
            const styleElement = document.querySelector('style');
            styleElement.textContent += `
            .player div {
                display: flex;
                align-items: center;
                position: relative;
            }
            .player .decrease, .player .increase {
                cursor: pointer;
                position: absolute;
                top: 50%;
                transform: translateY(-50%);
                width: 30px;
                height: 30px;
                display: flex;
                justify-content: center;
                align-items: center;
                font-size: 16px;
            }
            .player .decrease {
                left: -45px;
            }
            .player .increase {
                right: -45px;
            }
            .player .decrease:hover, .player .increase:hover {
                background-color: lightgray;
            }
        `;

            // Add event listeners
            const decreaseButtons = document.querySelectorAll('.decrease');
            const increaseButtons = document.querySelectorAll('.increase');

            decreaseButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const scoreElement = button.nextElementSibling;
                    if (scoreElement.classList.contains('yourScore')) {
                        if (this.yourScore > 0) {
                            this.yourScore--;
                            scoreElement.innerHTML = this.yourScore;
                        }
                    } else if (scoreElement.classList.contains('opponentScore')) {
                        if (this.opponentScore > 0) {
                            this.opponentScore--;
                            scoreElement.innerHTML = this.opponentScore;
                        }
                    }
                });
            });

            increaseButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const scoreElement = button.previousElementSibling;
                    if (scoreElement.classList.contains('yourScore')) {
                        this.yourScore++;
                        scoreElement.innerHTML = this.yourScore;
                    } else if (scoreElement.classList.contains('opponentScore')) {
                        this.opponentScore++;
                        scoreElement.innerHTML = this.opponentScore;
                    }
                });
            });
        }

        resetScoreboard() {
            this.element.style.visibility = 'hidden';
            this.element.innerHTML = `
            <div class="scoreboard">
                <div class="player">
                    <span>You</span>
                    <strong class="yourScore">${this.yourScore}</strong>
                </div>
                <div class="player">
                    <span>Opponent</span>
                    <strong class="opponentScore">${this.opponentScore}</strong>
                </div>
            </div>
        `;
        }
    }

    // ===== BASE ZONE ALERT =====
    class BaseZoneAlert {
        constructor() {
            this.active = false;
            this._createAlertElement();
        }

        _createAlertElement() {
            this.element = createElement('div', {}, {
                display: 'none',
                zIndex: '9999',
                position: 'relative'
            }, document.body);
        }

        update() {
            if (!this.active || !player || player.dead) {
                this.element.style.display = 'none';
                return;
            }

            const gamemode = player.gamemode;

            if (gamemode === 'teams') {
                this._updateTeamsAlert();
            } else if (gamemode === '4teams') {
                this._update4TeamsAlert();
            } else {
                this.element.style.display = 'none';
            }
        }

        _updateTeamsAlert() {
            if ((player.x < 0.25 || player.x > 0.75) && player.x !== NaN) {
                this.element.style.display = 'block';

                // Blue base
                if (player.x < 0.25) {
                    if (player.x < 0.194) {
                        this.element.innerHTML = `
                        <div style="${styles.baseZoneAlert}; color: #00b2e1; font-size: 5.85vh;">
                            Blue drones are attacking you
                        </div>`;
                    } else {
                        this.element.innerHTML = `
                        <div style="${styles.baseZoneAlert}; color: #00b2e1;">
                            Blue drones can chase you
                        </div>`;
                    }
                }

                // Red base
                if (player.x > 0.75) {
                    if (player.x > 0.806) {
                        this.element.innerHTML = `
                        <div style="${styles.baseZoneAlert}; color: #f14e54; font-size: 5.85vh;">
                            Red drones are attacking you
                        </div>`;
                    } else {
                        this.element.innerHTML = `
                        <div style="${styles.baseZoneAlert}; color: #f14e54;">
                            Red drones can chase you
                        </div>`;
                    }
                }
            } else {
                this.element.style.display = 'none';
            }
        }

        _update4TeamsAlert() {
            const distFromBlue = Math.sqrt(Math.pow(player.x - 0.075, 2) + Math.pow(player.y - 0.075, 2));
            const distFromRed = Math.sqrt(Math.pow(player.x - 0.925, 2) + Math.pow(player.y - 0.925, 2));
            const distFromGreen = Math.sqrt(Math.pow(player.x - 0.075, 2) + Math.pow(player.y - 0.925, 2));
            const distFromPurple = Math.sqrt(Math.pow(player.x - 0.925, 2) + Math.pow(player.y - 0.075, 2));

            if ((distFromBlue < 0.237 || distFromRed < 0.237 || distFromGreen < 0.237 || distFromPurple < 0.237) && player.x !== NaN) {
                this.element.style.display = 'block';

                // Blue base
                if (distFromBlue < 0.237) {
                    if (distFromBlue < 0.17) {
                        this.element.innerHTML = `
                        <div style="${styles.baseZoneAlert}; color: #00b2e1; font-size: 5.85vh;">
                            Blue drones are attacking you
                        </div>`;
                    } else {
                        this.element.innerHTML = `
                        <div style="${styles.baseZoneAlert}; color: #00b2e1;">
                            Blue drones can chase you
                        </div>`;
                    }
                }

                // Red base
                if (distFromRed < 0.237) {
                    if (distFromRed < 0.17) {
                        this.element.innerHTML = `
                        <div style="${styles.baseZoneAlert}; color: #f14e54; font-size: 5.85vh;">
                            Red drones are attacking you
                        </div>`;
                    } else {
                        this.element.innerHTML = `
                        <div style="${styles.baseZoneAlert}; color: #f14e54;">
                            Red drones can chase you
                        </div>`;
                    }
                }

                // Green base
                if (distFromGreen < 0.237) {
                    if (distFromGreen < 0.17) {
                        this.element.innerHTML = `
                        <div style="${styles.baseZoneAlert}; color: #00e16e; font-size: 5.85vh;">
                            Green drones are attacking you
                        </div>`;
                    } else {
                        this.element.innerHTML = `
                        <div style="${styles.baseZoneAlert}; color: #00e16e;">
                            Green drones can chase you
                        </div>`;
                    }
                }

                // Purple base
                if (distFromPurple < 0.237) {
                    if (distFromPurple < 0.17) {
                        this.element.innerHTML = `
                        <div style="${styles.baseZoneAlert}; color: #bf7ff5; font-size: 5.85vh;">
                            Purple drones are attacking you
                        </div>`;
                    } else {
                        this.element.innerHTML = `
                        <div style="${styles.baseZoneAlert}; color: #bf7ff5;">
                            Purple drones can chase you
                        </div>`;
                    }
                }
            } else {
                this.element.style.display = 'none';
            }
        }

        toggle() {
            this.active = !this.active;
            this.update();
            return this.active;
        }
    }

    // ===== BUTTON ACTIONS =====
    const buttonActions = {
        afk: function() {
            this.active = !this.active;
            if (this.active) {
                this.style.backgroundColor = "#008000";
                this.x = player.x;
                this.y = player.y;
            } else {
                extern.onKeyUp(1);
                extern.onKeyUp(4);
                extern.onKeyUp(23);
                extern.onKeyUp(19);
                this.style.backgroundColor = "#2B2D2F";
            }
        },

        repelNecro: function() {
            this.active = !this.active;
            if (this.active) {
                let repelTime = 25 * 1000;
                extern.onKeyDown(34);
                this.repelInterval = setInterval(() => {
                    extern.onKeyDown(34);
                    setTimeout(() => extern.onKeyUp(34), repelTime);
                }, 2 * repelTime + 1300);
                this.style.backgroundColor = "#008000";
            } else {
                clearInterval(this.repelInterval);
                extern.onKeyUp(34);
                this.style.backgroundColor = "#2B2D2F";
            }
        },

        repelOverlord: function() {
            this.active = !this.active;
            if (this.active) {
                let repelTime = 60 * 1000;
                extern.onKeyDown(34);
                this.repelInterval = setInterval(() => {
                    extern.onKeyUp(34);
                    setTimeout(() => extern.onKeyDown(16), 3000);
                }, repelTime);
                this.style.backgroundColor = "#008000";
            } else {
                clearInterval(this.repelInterval);
                extern.onKeyUp(34);
                this.style.backgroundColor = "#2B2D2F";
            }
        },

        upAndDown: function() {
            this.active = !this.active;
            if (this.active) {
                this.down = true;
                this.x = player.x;
                this.style.backgroundColor = "#008000";
            } else {
                extern.onKeyUp(1);
                extern.onKeyUp(4);
                extern.onKeyUp(23);
                extern.onKeyUp(19);
                this.style.backgroundColor = "#2B2D2F";
            }
        },

        predictionMovement: function() {
            this.active = !this.active;
            if (this.active) {
                localStorage.setItem('predictionMovement', 'true');
                input.set_convar("net_predict_movement", true);
                this.style.backgroundColor = "#008000";
            } else {
                localStorage.setItem('predictionMovement', 'false');
                input.set_convar("net_predict_movement", false);
                this.style.backgroundColor = "#2B2D2F";
            }
        },

        hideUpgrades: function() {
            this.active = !this.active;
            if (this.active) {
                input.set_convar("ren_upgrades", false);
                this.style.backgroundColor = "#008000";
            } else {
                input.set_convar("ren_upgrades", true);
                this.style.backgroundColor = "#2B2D2F";
            }
        },

        hideUI: function() {
            this.active = !this.active;
            if (this.active) {
                input.set_convar("ren_ui", false);
                this.style.backgroundColor = "#008000";
            } else {
                input.set_convar("ren_ui", true);
                this.style.backgroundColor = "#2B2D2F";
            }
        },

        predatorStack: function() {
            if (player.tank === "Predator" || player.tank === "Hunter") {
                this.style.backgroundColor = "#008000";
                this.active = true;

                const reload = 7;
                const predator = [
                    [50, 500, 1400, 2800], // 0 reload
                    [50, 500, 1300, 2700], // 1 reload
                    [50, 400, 1200, 2450], // 2 reload
                    [50, 300, 1100, 2200], // 3 reload
                    [50, 300, 1000, 2100], // 4 reload
                    [50, 300, 900, 1800],  // 5 reload
                    [50, 300, 800, 1700],  // 6 reload
                    [50, 300, 750, 1500],  // 7 reload
                ];

                const hunter = [
                    [50, 1200], // 0 reload
                    [50, 1100], // 1 reload
                    [50, 1000], // 2 reload
                    [50, 950],  // 3 reload
                    [50, 800],  // 4 reload
                    [50, 725],  // 5 reload
                    [50, 700],  // 6 reload
                    [50, 625],  // 7 reload
                ];
                const btn = this;

                const shoot = (w) => {
                    extern.onKeyDown(36);
                    setTimeout(() => extern.onKeyUp(36), w);
                };

                if (player.tank === "Predator") {
                    shoot(predator[reload][0]);
                    setTimeout(() => {
                        shoot(predator[reload][1]);
                    }, predator[reload][2]);
                    setTimeout(() => {
                        extern.onKeyDown(36);
                        btn.style.backgroundColor = "#2B2D2F";
                        btn.active = false;
                    }, predator[reload][3]);
                } else if (player.tank === "Hunter") {
                    shoot(hunter[reload][0]);
                    setTimeout(() => {
                        extern.onKeyDown(36);
                        btn.style.backgroundColor = "#2B2D2F";
                        btn.active = false;
                    }, hunter[reload][1]);
                }
            }
        },

        baseZoneAlert: function() {
            this.active = !this.active;
            if (this.active) {
                baseZoneAlert.active = true;
                this.style.backgroundColor = "#008000";
            } else {
                baseZoneAlert.active = false;
                this.style.backgroundColor = "#2B2D2F";
            }
        },

        autoRespawn: function() {
            this.active = !this.active;
            if (this.active) {
                grantReward();
                respawnPlayer();
                this.style.backgroundColor = "#008000";
            } else {
                this.style.backgroundColor = "#2B2D2F";
            }
        },

        oneVsOneScore: function() {
            this.active = !this.active;
            if (this.active) {
                this.style.backgroundColor = "#008000";
                scoreboard.element.style.visibility = 'visible';
            } else {
                this.style.backgroundColor = "#2B2D2F";
                scoreboard.element.style.visibility = 'hidden';
            }
        },

        copyPartyLink: function() {
            this.style.backgroundColor = "#008000";
            setTimeout(() => {
                this.style.backgroundColor = "#2B2D2F";
            }, 100);
            document.getElementById("copy-party-link").click();
        },

        locationSharing: function() {
            this.active = !this.active;
            if (this.active) {
                locationSharingSystem.activate();
                this.style.backgroundColor = "#008000";
            } else {
                locationSharingSystem.deactivate();
                this.style.backgroundColor = "#2B2D2F";
            }
        },

        // Build buttons
        buildOL: function() {
            this.active = !this.active;
            if (this.active) {
                input.execute('game_stats_build 656565658484848456565848484633232');
                deactivateOtherBuildButtons(this);
                this.style.backgroundColor = "#008000";
            } else {
                input.execute('game_stats_build 0');
                this.style.backgroundColor = "#2B2D2F";
            }
        },

        buildSP: function() {
            this.active = !this.active;
            if (this.active) {
                input.execute('game_stats_build 656565658787878756565878787633232');
                deactivateOtherBuildButtons(this);
                this.style.backgroundColor = "#008000";
            } else {
                input.execute('game_stats_build 0');
                this.style.backgroundColor = "#2B2D2F";
            }
        },

        buildAN: function() {
            this.active = !this.active;
            if (this.active) {
                input.execute('game_stats_build 656565658484848456565848484677777');
                deactivateOtherBuildButtons(this);
                this.style.backgroundColor = "#008000";
            } else {
                input.execute('game_stats_build 0');
                this.style.backgroundColor = "#2B2D2F";
            }
        },

        buildRAM: function() {
            this.active = !this.active;
            if (this.active) {
                input.execute('game_stats_build 338823238228888323232777777711111');
                deactivateOtherBuildButtons(this);
                this.style.backgroundColor = "#008000";
            } else {
                input.execute('game_stats_build 0');
                this.style.backgroundColor = "#2B2D2F";
            }
        },

        buildFFAOL: function() {
            this.active = !this.active;
            if (this.active) {
                input.execute('game_stats_build 656565658484848456565848484633277');
                deactivateOtherBuildButtons(this);
                this.style.backgroundColor = "#008000";
            } else {
                input.execute('game_stats_build 0');
                this.style.backgroundColor = "#2B2D2F";
            }
        },

        buildPRED: function() {
            this.active = !this.active;
            if (this.active) {
                input.execute('game_stats_build 656565658484848456565844477677777');
                deactivateOtherBuildButtons(this);
                this.style.backgroundColor = "#008000";
            } else {
                input.execute('game_stats_build 0');
                this.style.backgroundColor = "#2B2D2F";
            }
        },

        buildFIGHTER: function() {
            this.active = !this.active;
            if (this.active) {
                input.execute('game_stats_build 656565658484848477777775656568884');
                deactivateOtherBuildButtons(this);
                this.style.backgroundColor = "#008000";
            } else {
                input.execute('game_stats_build 0');
                this.style.backgroundColor = "#2B2D2F";
            }
        },

        resetBinds: function() {
            mainGui.resetKeyCodes();
            buildGui.resetKeyCodes();
        }
    };

    // Helper function to deactivate other build buttons
    function deactivateOtherBuildButtons(activeButton) {
        buildGui._buttons.forEach(button => {
            if (button !== activeButton) {
                button.active = false;
                button.style.backgroundColor = "#2B2D2F";
            }
        });
    }

    // ===== KEY CODE MAPPING =====
    const codeToKey = {
        "Backquote": "`", "Backslash": "\\", "BracketLeft": "[", "BracketRight": "]",
        "Comma": ",", "Digit0": "0", "Digit1": "1", "Digit2": "2", "Digit3": "3",
        "Digit4": "4", "Digit5": "5", "Digit6": "6", "Digit7": "7", "Digit8": "8",
        "Digit9": "9", "Equal": "=", "IntlBackslash": "\\", "IntlRo": "", "IntlYen": "",
        "KeyA": "A", "KeyB": "B", "KeyC": "C", "KeyD": "D", "KeyE": "E", "KeyF": "F",
        "KeyG": "G", "KeyH": "H", "KeyI": "I", "KeyJ": "J", "KeyK": "K", "KeyL": "L",
        "KeyM": "M", "KeyN": "N", "KeyO": "O", "KeyP": "P", "KeyQ": "Q", "KeyR": "R",
        "KeyS": "S", "KeyT": "T", "KeyU": "U", "KeyV": "V", "KeyW": "W", "KeyX": "X",
        "KeyY": "Y", "KeyZ": "Z", "Minus": "-", "Period": ".", "Quote": "'", "Semicolon": ";",
        "Slash": "/", "Space": "", "Backspace": "Bksp", "Enter": "Ent", "Tab": "Tab",
        "CapsLock": "CapLck", "Escape": "Esc", "ArrowDown": "", "ArrowLeft": "",
        "ArrowRight": "", "ArrowUp": "", "End": "End", "Home": "Home", "Insert": "Ins",
        "PageDown": "PgDn", "PageUp": "PgUp", "Delete": "Del", "ContextMenu": "CtxMenu",
        "ControlLeft": "Ctrl", "ControlRight": "Ctrl", "AltLeft": "Alt", "AltRight": "Alt",
        "ShiftLeft": "Shift", "ShiftRight": "Shift", "MetaLeft": "Meta", "MetaRight": "Meta",
        "OSLeft": "OS", "OSRight": "OS", "F1": "F1", "F2": "F2", "F3": "F3", "F4": "F4",
        "F5": "F5", "F6": "F6", "F7": "F7", "F8": "F8", "F9": "F9", "F10": "F10",
        "F11": "F11", "F12": "F12", "NumLock": "NumLck", "ScrollLock": "ScrLck"
    };

    // ===== UTILITY FUNCTIONS =====
    function updateMillionsCounter(score) {
        millionsCounter.update(score, true);
    }

    function resetTimer() {
        rawTime = 0;
        clearInterval(timeInterval);
        time = '00:00:00';
        startTimer();
    }

    function startTimer() {
        timeInterval = setInterval(() => {
            if (getScore() >= 0) {
                let [hours, minutes, seconds] = time.split(':');

                if (parseInt(seconds) + 1 !== 60) {
                    let addZero = (parseInt(seconds) + 1).toString().length == 1 ? '0' : '';
                    seconds = `${addZero}${parseInt(seconds) + 1}`;
                    rawTime += 1;
                } else {
                    if (parseInt(minutes) + 1 !== 60) {
                        let addZero = (parseInt(minutes) + 1).toString().length == 1 ? '0' : '';
                        seconds = '00';
                        minutes = `${addZero}${parseInt(minutes) + 1}`;
                    } else {
                        let addZero = (parseInt(hours) + 1).toString().length == 1 ? '0' : '';
                        seconds = '00';
                        minutes = '00';
                        hours = `${addZero}${parseInt(hours) + 1}`;
                    }
                }

                time = `${hours}:${minutes}:${seconds}`;
            } else if (getScore() == -1) {
                time = '00:00:00';
                rawTime = 0;
            }

            updateButtonVisibility();
        }, 1000);
    }

    function respawnPlayer() {
        grantReward();
        extern.onKeyUp(1);
        extern.onKeyUp(4);
        extern.onKeyUp(23);
        extern.onKeyUp(19);

        const originalFunction = extern.onKeyDown;
        const emptyFunction = function() {};

        extern.onKeyDown = emptyFunction;

        setTimeout(() => {
            const spawnName = localStorage.getItem('d:last_spawn_name');
            if (spawnName) {
                input.execute('game_spawn "' + spawnName.slice(1, -1) + '"');
            }
        }, 300);

        setTimeout(() => {
            extern.onKeyDown = originalFunction;
        }, 1000);
    }

    // ===== TEXT RENDERING HOOKS =====
    function setupTextRenderingHooks() {
        let fl = false;
        let f2 = false;
        let numPlayers = 0;


        //  callback   
        const canvasCallback = function(thisArg, args, prop, addPendingCall) {
            //    fillText  strokeText
            if (prop !== 'fillText' && prop !== 'strokeText') return true;

            //  
            let [text, x, y, ...rest] = args;

            const isFillText = prop === 'fillText';

            // Measure line height
            const lineHeight = thisArg.measureText('M').width;

            // Replace "diep.io" with region
            if (text && text.includes && text.includes("diep.io")) {
                const lengthBefore = thisArg.measureText(text).width;
                text = localStorage.getItem('region') || '';
                thisArg.textAlign = 'right';
                x += lengthBefore;
                text = ''; // Clear text
                args[0] = text;
                args[1] = x;
            }

            // Update DOM for level/kills
            if (isFillText) {
                const levelElement = document.getElementById('game-over-stats-player-level');
                if (levelElement) {
                    levelElement.textContent = killCounter;
                    const frozenElement = levelElement.cloneNode(true);
                    levelElement.parentNode.replaceChild(frozenElement, levelElement);
                }

                // Replace "Level:" with "Kills:"
                const labels = document.querySelectorAll('.label');
                for (let i = 0; i < labels.length; i++) {
                    if (labels[i].textContent === 'Level:') {
                        labels[i].textContent = 'Kills:';
                    }
                }
            }

            // Hide player count
            if (text && text.includes && text.endsWith("players")) {
                text = "";
                args[0] = text;
            }

            // Replace "Level:" with "Kills:"
            if (text === "Level:") {
                text = "  Kills:";
                thisArg.textAlign = 'start';
                thisArg.lineWidth = thisArg.measureText(text).width;
                if (isFillText) {
                    fl = true;
                } else {
                    f2 = true;
                }
                args[0] = text;
            } else if ((isFillText && fl) || (!isFillText && f2)) {
                text = killCounter.toString();
                if (isFillText) fl = false;
                else f2 = false;
                args[0] = text;
            }

            // Align "Score:" and "Time Alive:"
            if (text === "Score:" || text === "Time Alive:") {
                thisArg.textAlign = 'start';
            }

            // Handle ping text
            if (text && text.includes && text.includes("ms") && text.includes(".")) {
                lastMsTime = new Date();
                const lengthBefore = thisArg.measureText(text).width;
                text = text.split(" ms")[0] + "ms " + numPlayers;

                thisArg.textAlign = 'right';
                thisArg.textBaseline = "alphabetic";
                thisArg.font = parseFloat(thisArg.font) * 0.912 + "px Ubuntu";

                x += lengthBefore;
                args[0] = text;
                args[1] = x;

                if (typeof time !== 'undefined') {
                    const timeY = y + thisArg.measureText('M').actualBoundingBoxAscent + 1;
                    addPendingCall(prop, [time, x, timeY, ...rest]);
                }
            }

            return true;
        };

        hookManager.addCallback(canvasCallback);

        let blacklist = [];
        hookManager.addCallback(function(thisArg, args, prop) {
            if (prop !== 'fillText') return true;

            const [text] = args;
            if (text && text.startsWith && text.startsWith("You've killed ")) {
                if (blacklist.indexOf(text) === -1) {
                    killCounter += 1;
                    blacklist.push(text);

                    setTimeout(() => {
                        const index = blacklist.indexOf(text);
                        if (index !== -1) {
                            blacklist.splice(index, 1);
                        }
                    }, 1000);

                    setTimeout(() => {
                        blacklist.push(text);
                    }, 4600);

                    setTimeout(() => {
                        const index = blacklist.indexOf(text);
                        if (index !== -1) {
                            blacklist.splice(index, 1);
                        }
                    }, 5000);
                }
            }

            return true;
        });

        async function fetchPlayerCount() {
            try {
                const response = await fetch('https://lb.diep.io/api/lb/pc');
                if (!response.ok) throw new Error('Network response was not ok');

                const data = await response.json();
                if (!player || !player.region || !player.gamemode) return;

                const region = player.region;
                const gamemode = player.gamemode;

                const regionData = data.regions.find(r => r.region === region);
                if (!regionData) return;

                const lobby = regionData.lobbies.find(l => l.gamemode === gamemode);
                if (lobby) {
                    numPlayers = lobby.numPlayers;
                }
            } catch (error) {
                console.log("API rate limit exceeded");
            }
        }

        setInterval(fetchPlayerCount, 5000);
    }

    // ===== BUTTON VISIBILITY MANAGEMENT =====
    let currentGamemode = null;

    function updateButtonVisibility() {
        if (currentGamemode === player.gamemode) {
            return;
        }

        console.log("Gamemode changed from", currentGamemode, "to", player.gamemode);
        currentGamemode = player.gamemode;

        const gamemode = player.gamemode;

        // Remove existing buttons
        mainGui.destroy();
        buildGui.destroy();

        // Create new GUI instances
        mainGui = new BaseGui('right');
        buildGui = new BaseGui('left');

        // Define button visibility based on gamemode
        const buttonConfig = {
            afk: ['teams', '4teams'],
            repelNecro: ['teams', '4teams'],
            repelOverlord: ['teams', '4teams'],
            upAndDown: ['teams'],
            predictionMovement: ['sandbox', 'ffa', 'maze', 'event', 'teams', '4teams'],
            hideUpgrades: ['sandbox', 'ffa', 'maze', 'event', 'teams', '4teams'],
            hideUI: ['sandbox', 'ffa', 'maze', 'event', 'teams', '4teams'],
            predatorStack: ['sandbox', 'ffa', 'maze', 'event', 'teams', '4teams'],
            baseZoneAlert: ['teams', '4teams'],
            autoRespawn: ['sandbox', 'ffa', 'maze', 'event', 'teams', '4teams'],
            oneVsOneScore: ['sandbox'],
            copyPartyLink: ['sandbox', 'event', 'teams', '4teams'],
            locationSharing: ['sandbox', 'ffa', 'maze', 'event', 'teams', '4teams']
        };

        // Add buttons based on gamemode
        for (const [buttonName, gamemodes] of Object.entries(buttonConfig)) {
            if (gamemodes.includes(gamemode)) {
                const actionName = buttonName.charAt(0).toLowerCase() + buttonName.slice(1);
                const keyCode = getDefaultKeyCode(buttonName);

                const btnVarName = 'btn' + buttonName.charAt(0).toUpperCase() + buttonName.slice(1);

                switch (buttonName) {
                    case 'afk':
                        btnAfk = mainGui.addButton(formatButtonName(buttonName), buttonActions[actionName], keyCode);
                        break;
                    case 'upAndDown':
                        btnUpAndDown = mainGui.addButton(formatButtonName(buttonName), buttonActions[actionName], keyCode);
                        break;
                    case 'hideUI':
                        btnHideUI = mainGui.addButton(formatButtonName(buttonName), buttonActions[actionName], keyCode);
                        break;
                    case 'autoRespawn':
                        btnAutoRespawn = mainGui.addButton(formatButtonName(buttonName), buttonActions[actionName], keyCode);
                        break;
                    default:
                        mainGui.addButton(formatButtonName(buttonName), buttonActions[actionName], keyCode);
                        break;
                }
            }
        }

        // Always add build buttons
        if (gamemode) {
            btnBuildOL = buildGui.addButton('OverLord', buttonActions.buildOL);
            btnBuildSP = buildGui.addButton('SpreadShot', buttonActions.buildSP);
            btnBuildAN = buildGui.addButton('Annihilator', buttonActions.buildAN);
            btnBuildRAM = buildGui.addButton('Rammer', buttonActions.buildRAM);
            btnBuildFFAOL = buildGui.addButton('FFA OL', buttonActions.buildFFAOL);
            btnBuildPRED = buildGui.addButton('Predator', buttonActions.buildPRED);
            btnBuildFIGHTER = buildGui.addButton('Fighter', buttonActions.buildFIGHTER);
        }

        // Restore button states
        restoreButtonStates();
    }
    function formatButtonName(name) {
        // Convert camelCase to space-separated words
        return name.replace(/([A-Z])/g, ' $1')
            .replace(/^./, str => str.toUpperCase())
            .trim()
            .replace('One Vs One', '1v1')
            .replace('Ui', 'UI');
    }

    function getDefaultKeyCode(buttonName) {
        const keyMap = {
            'afk': 'KeyQ',
            'upAndDown': 'KeyN',
            'hideUI': 'KeyY',
            'predatorStack': 'KeyP',
            'baseZoneAlert': 'KeyB',
            'autoRespawn': 'KeyR',
            'locationSharing': 'KeyG'
        };

        return keyMap[buttonName] || null;
    }

    function restoreButtonStates() {
        // Restore prediction movement state
        const btnPredictMovement = mainGui._buttons.find(btn => btn.innerHTML === 'Prediction Movement');
        if (btnPredictMovement && localStorage.getItem('predictionMovement') === 'true') {
            btnPredictMovement.active = true;
            btnPredictMovement.style.backgroundColor = '#008000';
            input.set_convar("net_predict_movement", true);
        }
        if (btnPredictMovement && localStorage.getItem('predictionMovement') === 'false') {
            btnPredictMovement.active = false;
            btnPredictMovement.style.backgroundColor = '#2B2D2F';
            input.set_convar("net_predict_movement", false);
        }

        // Restore base zone alert state
        const btnBaseZoneAlert = mainGui._buttons.find(btn => btn.innerHTML === 'Base Alert');
        if (btnBaseZoneAlert && baseZoneAlert.active) {
            btnBaseZoneAlert.active = true;
            btnBaseZoneAlert.style.backgroundColor = '#008000';
        }
    }

    // ===== KEYBOARD EVENT HANDLING =====
    function setupKeyboardEvents() {
        let timer;

        document.addEventListener('keydown', (event) => {
            // Skip if text input is active
            if (document.getElementById('textInputContainer').style.display === 'block') return;

            if (event.code === 'KeyF') {
                if (mainGui._guiBody.style.display === 'block' || buildGui._guiBody.style.display === 'block') {
                    mainGui._guiBody.style.display = 'none';
                    buildGui._guiBody.style.display = 'none';
                } else {
                    mainGui._guiBody.style.display = 'block';
                    buildGui._guiBody.style.display = 'block';
                }
                return;
            }

            // Toggle settings with Shift+Plus
            if (event.code === 'Equal' && event.shiftKey) {
                if (settingsGui._guiBody.style.display === 'none') {
                    settingsGui._guiBody.style.display = 'block';
                    mainGui._guiBody.style.display = 'block';
                    buildGui._guiBody.style.display = 'block';

                    millionsCounter.show();
                    millionsCounter.createEditableCounters();

                    if (btnOneVsOneScore && btnOneVsOneScore.active) {
                        scoreboard.createEditableScoreboard();
                    }
                } else {
                    settingsGui._guiBody.style.display = 'none';

                    millionsCounter.hide();
                    millionsCounter.update();

                    scoreboard.resetScoreboard();
                }
                return;
            }

            // Toggle always K
            if (event.code === 'KeyK' && event.isTrusted) {
                isActiveK = !isActiveK;
                input.inGameNotification("Always K", isActiveK ? 3273729 : 0, 3000);
                return;
            }

            // Toggle always L
            if (event.code === 'KeyL' && event.isTrusted) {
                isActiveL = !isActiveL;
                input.inGameNotification("Always L", isActiveL ? 3273729 : 0, 3000);
                return;
            }

            // Reset builds with double-U
            if (event.code === 'KeyU') {
                const now = Date.now();
                if (now - lastUKeyTime <= 300) { // Double press within 300ms
                    buildGui._buttons.forEach(button => {
                        button.active = false;
                        button.style.backgroundColor = "#2B2D2F";
                    });
                    input.execute('game_stats_build 0');
                }
                lastUKeyTime = now;
                return;
            }

            // Mark O key press
            if (event.code === 'KeyO') {
                pressedO = true;
                if (timer) clearTimeout(timer);
                timer = setTimeout(() => {
                    pressedO = false;
                }, 6000);
                return;
            }

            // Handle Enter key for build selection
            if (event.code === 'Enter') {
                if (player.dead) {
                    grantReward();
                } else {
                    buildGui._buttons.forEach(button => {
                        if (button.style.backgroundColor === "rgb(184, 134, 11)" || button.style.backgroundColor === "rgb(0, 128, 0)") {
                            button.active = true;
                            button.style.backgroundColor = "#008000";
                        } else {
                            button.style.backgroundColor = "#2B2D2F";
                            button.active = false;
                        }
                    });

                    if (mainGui._guiBody.style.display === 'none') {
                        buildGui._guiBody.style.display = 'none';
                    }
                }
            }
        });

        // Grant reward on mouse click when dead
        document.addEventListener('mousedown', function(e) {
            if (e.button === 0 && player.dead) {
                grantReward();
            }
        });
    }

    // ===== MAIN INITIALIZATION =====
    function initialize() {
        (function() {
            function ensureElementExists(id) {
                let el = document.createElement("div");
                el.id = id;
                el.style.display = "none";
                document.body.appendChild(el);

            }

            ensureElementExists("quick-joystick-settings");
            ensureElementExists("quick-upgrade-tree-view");
        })();

        // Initialize core components
        hookManager = new CanvasHookManager();
        player = new Player();
        minimap = player._minimap;
        millionsCounter = new MillionsCounter();
        scoreboard = new Scoreboard();
        baseZoneAlert = new BaseZoneAlert();
        locationSharingSystem = new LocationSharing();

        // Initialize GUI
        mainGui = new BaseGui('right');
        buildGui = new BaseGui('left');
        settingsGui = new SettingsGui();

        // Add settings button
        btnResetBinds = settingsGui.addButton('Reset binds', buttonActions.resetBinds);

        // Setup hooks and events
        setupTextRenderingHooks();
        setupKeyboardEvents();

        // Initialize timer
        startTimer();

        // Set prediction movement from localStorage
        if (localStorage.getItem('predictionMovement') === null) {
            localStorage.setItem('predictionMovement', 'false');
        }

        // Remove annoying button
        const annoying_button = document.getElementById("in-game-quick-buttons");
        if (annoying_button) annoying_button.remove();

        // Setup periodic tasks
        setInterval(() => {
            // Handle always K
            if (isActiveK && getScore() >= 0) {
                extern.onKeyDown(11);
            } else {
                extern.onKeyUp(11);
            }

            let now = new Date;
            if (isActiveL && now - lastMsTime > 1000) {
                extern.onKeyDown(12);
                extern.onKeyUp(12);
            } else {
                extern.onKeyUp(12);
            }

            // Handle AFK and Up/Down movement
            if (btnAfk && btnAfk.active) {
                player.goto(btnAfk.x, btnAfk.y);
            } else if (btnUpAndDown && btnUpAndDown.active) {
                if (btnUpAndDown.down) {
                    player.goto(btnUpAndDown.x, 1);
                    if (player.y >= 0.95) btnUpAndDown.down = false;
                } else {
                    player.goto(btnUpAndDown.x, 0);
                    if (player.y <= 0.05) btnUpAndDown.down = true;
                }
            }

            // Update base zone alert
            baseZoneAlert.update();

            // Show/hide millions counter based on game state
            if ((getScore() !== -1 || (btnHideUI && btnHideUI.active)) && settingsGui._guiBody.style.display === 'none') {
                millionsCounter.hide();
            } else {
                millionsCounter.show();
            }

            // Show build buttons when dead
            if (getScore() === -1 && !showedBuilds && (!btnAutoRespawn || !btnAutoRespawn.active)) {
                let someButtonActive = false;
                buildGui._buttons.forEach(button => {
                    button.style.backgroundColor = "#2B2D2F";
                    if (button.active) {
                        button.style.backgroundColor = "#B8860B";
                        someButtonActive = true;
                    }
                });

                if (someButtonActive) {
                    buildGui._guiBody.style.display = 'block';
                } else if (mainGui._guiBody.style.display === 'none') {
                    buildGui._guiBody.style.display = 'none';
                }

                showedBuilds = true;
            }
        }, 100);

        // Ensure build states are maintained
        setInterval(() => {
            if (btnBuildOL && btnBuildOL.active) input.execute('game_stats_build 656565658484848456565848484633232');
            if (btnBuildSP && btnBuildSP.active) input.execute('game_stats_build 656565658787878756565878787633232');
            if (btnBuildAN && btnBuildAN.active) input.execute('game_stats_build 656565658484848456565848484677777');
            if (btnBuildRAM && btnBuildRAM.active) input.execute('game_stats_build 338823238228888323232777777711111');
            if (btnBuildFFAOL && btnBuildFFAOL.active) input.execute('game_stats_build 656565658484848456565848484633277');
            if (btnBuildPRED && btnBuildPRED.active) input.execute('game_stats_build 656565658484848456565844477677777');
            if (btnBuildFIGHTER && btnBuildFIGHTER.active) input.execute('game_stats_build 656565658484848477777775656568884');

            // Remove privacy settings button
            const privacyButton = document.getElementById("qc-cmp2-container");
            if (privacyButton) privacyButton.parentElement.removeChild(privacyButton);
        }, 1000);
    }

    // Start the script when DOM is loaded
    window.addEventListener('DOMContentLoaded', initialize);
})();